/* @flow */
import type {EventHandler, PropertiesConfig, SlotsData} from './types';

export interface Indexable {
	[key: any]: any;
}

export interface ICustomElement extends Indexable {
	static observedAttributes: string[];

	static finalizeClass(): void;

	static define(tagName: string): void;

	/**
	 * Called during creation time,
	 * subclasses extend override this, and should not use `constructor`
	 */
	construct(): void;

	isConnected(): boolean;

	/**
	 * Called when an observed attribute has been added, removed, updated, or replaced.
	 * Also called for initial values when an element is created by the parser, or upgraded.
	 * Note: only attributes listed in the observedAttributes property will receive this callback.
	 */
	// attributeChangedCallback(attributeName: string, oldValue: string, newValue: string): void;
	attributeChanged(attributeName: string, oldValue: string, newValue: string): void;

	/**
	 * Called every time the element is inserted into the DOM.
	 * Useful for running setup code, such as fetching resources or rendering.
	 * Generally, you should try to delay work until this time.
	 */
	// connectedCallback(): void;
	connected(): void;

	/**
	 * Called every time the element is removed from the DOM. Useful for running clean up code.
	 */
	disconnected(): void;

	/**
	 * The custom element has been moved into a new document (e.g. someone called document.adoptNode(el)).
	 */
	// adoptedCallback(): void;
	adopted(): void;

	render(): void;

	_onRender(firstRender: boolean): void;

	_postRender(firstRender: boolean): void;
}

export interface IEvents extends Indexable {
	[key: string]: Function;

	handleEvent(evt: Event): void;

	on(type: string, listener: Function, capture: boolean): void;

	dispatch(type: string, data: Object): void;

	off(): void;

	own(...handlers: Array<EventHandler>): void;
}

export interface IProperties {
	static +classProperties: PropertiesConfig;

	static createProperties(): void;

	static attributeToPropertyName(attribute: string): string;

	static propertyNameToAttribute(property: string): string;

	propertiesChanged(currentProps: Object, changedProps: Object, oldProps: Object): void;

	_createPropertyAccessor(property: string, readOnly: boolean): void;

	_getProperty(property: string): any;

	_setProperty(property: string, newValue: any): void;

	_initializeProtoProperties(): void;

	_initializeProperties(): void;

	_attributeToProperty(attribute: string, value: string): void;

	_isValidPropertyValue(property: string, value: any): boolean;

	_propertyToAttribute(property: string, value: any): void;

	_deserializeValue(property: string, value: any): any;

	_serializeValue(property: string, value: any): any;

	_setPendingProperty(property: string, value: any): boolean;

	_invalidateProperties(): void;

	_flushProperties(): void;

	_shouldPropertiesChange(currentProps: Object, changedProps: Object, oldProps: Object): boolean;

	_shouldPropertyChange(property: string, value: any, old: any): boolean;
}

export interface IState extends Indexable {
	+state: Object;

	setState(changes: Object, render: boolean): void;

	shouldComponentUpdate(nextState: Object): boolean;

	componentWillRender(newState: Object): void;

	componentWillUpdate(newState: Object, previousState: Object): void;

	componentDidRender(previousState: Object): void;

	componentDidUpdate(previousState: Object): void;
}

export interface ISlots {
	slots: SlotsData;

	slotsAssigned(): void;
}
